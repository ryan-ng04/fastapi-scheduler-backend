# main.py

# Import required libraries
from fastapi import FastAPI, HTTPException, Depends, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import RedirectResponse
from pymongo import MongoClient
from pydantic import BaseModel
from typing import List
import uuid
import os
import google.auth.transport.requests
from google_auth_oauthlib.flow import Flow
from google.oauth2.credentials import Credentials
import googleapiclient.discovery

# Initialize FastAPI app
app = FastAPI()

# Enable CORS to allow frontend access
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Change to frontend origin in production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# MongoDB setup
client = MongoClient("mongodb://localhost:27017")  # Connect to local MongoDB
db = client.smart_scheduler                      # Use database named "smart_scheduler"
tasks_collection = db.tasks                      # Collection for storing tasks
tokens_collection = db.tokens                    # Collection for storing Google tokens

# Define Task model using Pydantic
class Task(BaseModel):
    id: str = str(uuid.uuid4())  # Unique ID generated by default
    title: str
    description: str
    start_time: str
    end_time: str
    status: str = "pending"      # Default status

# =======================
# Task CRUD Endpoints
# =======================

# Retrieve all tasks
@app.get("/tasks", response_model=List[Task])
def get_tasks():
    tasks = list(tasks_collection.find({}, {'_id': 0}))  # Exclude MongoDB internal ID
    return tasks

# Create a new task
@app.post("/tasks")
def create_task(task: Task):
    tasks_collection.insert_one(task.dict())
    return {"message": "Task created successfully"}

# Update an existing task by ID
@app.put("/tasks/{task_id}")
def update_task(task_id: str, updated_task: Task):
    result = tasks_collection.update_one({"id": task_id}, {"$set": updated_task.dict()})
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Task not found")
    return {"message": "Task updated successfully"}

# Delete a task by ID
@app.delete("/tasks/{task_id}")
def delete_task(task_id: str):
    result = tasks_collection.delete_one({"id": task_id})
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Task not found")
    return {"message": "Task deleted successfully"}

# ================================
# Google Calendar OAuth2 & Sync
# ================================

# Environment variables for Google OAuth client credentials
CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID")
CLIENT_SECRET = os.getenv("GOOGLE_CLIENT_SECRET")
REDIRECT_URI = "http://localhost:8000/calendar/callback"  # Where Google redirects after login
SCOPES = ["https://www.googleapis.com/auth/calendar"]     # Permissions requested

# Start Google OAuth2 flow
@app.get("/calendar/auth")
def calendar_auth():
    flow = Flow.from_client_config(
        {
            "web": {
                "client_id": CLIENT_ID,
                "client_secret": CLIENT_SECRET,
                "redirect_uris": [REDIRECT_URI],
                "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                "token_uri": "https://oauth2.googleapis.com/token",
            }
        },
        scopes=SCOPES
    )
    flow.redirect_uri = REDIRECT_URI
    auth_url, _ = flow.authorization_url(prompt="consent", access_type="offline", include_granted_scopes="true")
    return RedirectResponse(auth_url)

# Handle OAuth2 callback and store access/refresh tokens
@app.get("/calendar/callback")
def calendar_callback(request: Request):
    code = request.query_params.get("code")
    flow = Flow.from_client_config(
        {
            "web": {
                "client_id": CLIENT_ID,
                "client_secret": CLIENT_SECRET,
                "redirect_uris": [REDIRECT_URI],
                "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                "token_uri": "https://oauth2.googleapis.com/token",
            }
        },
        scopes=SCOPES,
    )
    flow.redirect_uri = REDIRECT_URI
    flow.fetch_token(code=code)

    creds = flow.credentials
    # Save or update tokens in MongoDB
    tokens_collection.update_one({}, {"$set": creds_to_dict(creds)}, upsert=True)
    return {"message": "Google Calendar synced!"}

# Fetch calendar events using stored credentials
@app.get("/calendar/events")
def list_events():
    token_data = tokens_collection.find_one()
    if not token_data:
        raise HTTPException(status_code=401, detail="Google auth required")

    creds = Credentials.from_authorized_user_info(token_data, SCOPES)
    service = googleapiclient.discovery.build('calendar', 'v3', credentials=creds)
    events_result = service.events().list(calendarId='primary', maxResults=10).execute()
    return events_result.get('items', [])

# Helper function to convert credentials object to dictionary for DB storage
def creds_to_dict(creds):
    return {
        "token": creds.token,
        "refresh_token": creds.refresh_token,
        "token_uri": creds.token_uri,
        "client_id": creds.client_id,
        "client_secret": creds.client_secret,
        "scopes": creds.scopes,
    }
